// See LICENSE.txt for license details.
package mult8x8

import chisel3._
import chisel3.util._

// Problem:
//
// Implement a vending machine using 'when' states.
// 'nickel' is a 5 cent coin
// 'dime'   is 10 cent coin
// 'sOk' is reached when there are coins totalling 20 cents or more in the machine.
// The vending machine should return to the 'sIdle' state from the 'sOk' state.
//
class Control extends Module {
  val io = IO(new Bundle {

    //clk
    val reset = Input(Bool())
    val start = Input(Bool())
    val count = Input(UInt(2.W))

    val done  = Output(Bool())
    val clken  = Output(Bool())
    val regclr  = Output(Bool())

    val in_sel = Output(UInt(2.W))
    val shift = Output(UInt(2.W))
    val state_out = Output(UInt(3.W))
  
  })

  val sIdle :: sLsb :: sMid :: sMsb :: sErr :: Nil = Enum(5)

  val state = RegInit(sIdle)

  val mydone  = Reg(Bool())
  val myclken  = Reg(Bool())
  val myregclr  = Reg(Bool())

  val myin_sel = Reg(UInt(2.W))
  val myshift = Reg(UInt(2.W))
  val mystate_out = Reg(UInt(3.W))


  when (io.reset) {
    state:=sIdle
    mystate_out:=0.U(3.W)
    myin_sel:=0.U(2.W)
    myshift:=0.U(2.W)
    mydone:=0.U
    myclken:=1.U
    myregclr:=1.U
  }
  .otherwise{
  when (state === sIdle) {
    mystate_out:=0.U(3.W)
    when(io.start===1.U(1.W)) 
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=0.U
      state := sLsb 
    }
    .otherwise
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=1.U
    }
  }

  when (state === sLsb) {
    mystate_out:=1.U(3.W)
    when(io.start===1.U(1.W)) 
//    when (~io.start) //   && io.count===0.U(2.W)) 
    { 
      myin_sel:=0.U(2.W)
      myshift:=0.U(2.W)
      mydone:=0.U
      myclken:=0.U
      myregclr:=1.U
      state:=sMid 
    }
    .otherwise 
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=1.U
      state:=sErr
    }

  }
  when (state === sMid) {
    mystate_out:=2.U(3.W)
    when (io.start) // && io.count===1.U(2.W)) 
    /*{ 
      myin_sel:=1.U(2.W)
      myshift:=1.U(2.W)
      mydone:=0.U
      myclken:=0.U
      myregclr:=1.U
    }
    .elsewhen (~io.start)//  && io.count===2.U(2.W)) */
    { 
      myin_sel:=2.U(2.W)
      myshift:=1.U(2.W)
      mydone:=0.U
      myclken:=0.U
      myregclr:=1.U
      state:=sMsb 
    }
    .otherwise 
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=1.U
      state:=sErr
    }
  }
  when (state === sMsb) {
    mystate_out:=3.U(3.W)
    when (io.start) //&& io.count===3.U(2.W)) 
    {       
      myin_sel:=3.U(2.W)
      myshift:=2.U(2.W)
      mydone:=1.U
      myclken:=0.U
      myregclr:=1.U
      state:=sIdle 
    }
    .otherwise 
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=1.U
      state:=sErr
    }
  }
  when (state === sErr) {
    mystate_out:=4.U(3.W)
    when (io.start) { 
      mydone:=0.U
      myclken:=1.U
      myregclr:=0.U
      state := sLsb 
    }
    .otherwise 
    {
      mydone:=0.U
      myclken:=1.U
      myregclr:=1.U
    }

  }
  }
  io.state_out:=mystate_out
  io.in_sel:=myin_sel
  io.shift:=myshift
  io.done:=mydone
  io.clken:=myclken
  io.regclr:=myregclr

}
